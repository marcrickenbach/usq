/* *****************************************************************************
 * @brief Pot implementation.
 */

/* *****************************************************************************
 * TODO

    Implement Filter on ADC readings. They're currently all over the place and 
    cause pot_change broadcast event to over-fire, resulting in crashes down
    the line. 

    Abstract more? Right now this module is somewhat cemented in the mux config
    for my project. Biggest sticking point for me at the moment is how to account
    for various mux pins, particularly in the mux adv function. 
 */

/* *****************************************************************************
 * Includes
 */

#include "pot.h"

#include <zephyr/smf.h>
#include <zephyr/kernel.h>

#include <zephyr/drivers/adc.h>
#include <zephyr/drivers/gpio.h>

#include <assert.h>

#include <stdlib.h>

#include "pot/private/sm_evt.h"
#include "pot/private/module_data.h"

/* *****************************************************************************
 * Constants, Defines, and Macros
 */

#define SUCCESS (0)
#define FAIL    (-1)

#define OVERRIDE    true
#define NO_OVERRIDE false

#define ADC_NODE            DT_NODELABEL(adc1)
#define ADC_RESOLUTION      12          
#define ADC_CHANNEL         BIT(7)  // for multiple channels: || BIT(ADC CHANNEL No.)
#define ADC_REFERENCE       ADC_REF_INTERNAL
#define ADC_GAIN            ADC_GAIN_1
#define ADC_BUFFER_SIZE     1

#define GPIO_PINS           DT_PATH(zephyr_user)

#define GPIOB_PORT          DEVICE_DT_GET(DT_NODELABEL(gpiob))
#define GPIOC_PORT          DEVICE_DT_GET(DT_NODELABEL(gpioc))
#define MUX_BANK_MASK       0x01F0 // for GPIO C pins 4 -> 8
#define MUX_GPIO_OFFSET     4 // we're starting from GPIOC Pin 4 
#define MUX_ADDR_MASK       0x07
/* *****************************************************************************
 * Debugging
 */

#if CONFIG_FKMG_POT_NO_OPTIMIZATIONS
#pragma GCC push_options
#pragma GCC optimize ("Og")
#warning "pot.c unoptimized!"
#endif

#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(pot);

/* *****************************************************************************
 * Structs
 */

static struct pot_module_data pot_md = {0};
/* Convenience accessor to keep name short: md - module data. */
#define md pot_md

const struct device * adc_dev = DEVICE_DT_GET(ADC_NODE); 

// MUX Address Pins
const struct gpio_dt_spec adc_address_0 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_0_gpios); 
const struct gpio_dt_spec adc_address_1 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_1_gpios); 
const struct gpio_dt_spec adc_address_2 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_2_gpios); 

// MUX Bank Select Pins
const struct gpio_dt_spec adc_bank_0 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_bank_0_gpios); 
const struct gpio_dt_spec adc_bank_1 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_bank_1_gpios); 
const struct gpio_dt_spec adc_bank_2 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_bank_2_gpios); 
const struct gpio_dt_spec adc_bank_3 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_bank_3_gpios); 
const struct gpio_dt_spec adc_bank_4 = GPIO_DT_SPEC_GET(GPIO_PINS, adc_addr_bank_4_gpios); 

uint16_t adc_lut[4096] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 190, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 210, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 310, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 370, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 570, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 670, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 690, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 730, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 810, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 870, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 910, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 990, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1090, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1130, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1170, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1190, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1230, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1270, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1310, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1330, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1370, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1390, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1410, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1430, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1470, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1510, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1530, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1570, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1590, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1610, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1630, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1670, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1690, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1830, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1890, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1930, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1970, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 1990, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2030, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2050, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2070, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2090, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2110, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2130, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2150, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2190, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2210, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2270, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2290, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2310, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2330, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2350, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2370, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2410, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2430, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2450, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2490, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2510, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2530, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2570, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2590, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2610, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2630, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2650, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2670, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2690, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2710, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2730, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2770, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2790, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2830, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2870, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2890, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2910, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2930, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2950, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2970, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 2990, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3010, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3030, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3050, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3070, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3090, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3110, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3130, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3170, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3190, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3210, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3230, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3250, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3270, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3290, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3310, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3330, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3350, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3370, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3390, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3410, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3430, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3470, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3490, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3510, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3530, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3550, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3570, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3590, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3610, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3630, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3650, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3670, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3690, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3710, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3730, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3770, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3790, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3810, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3830, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3850, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3870, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3890, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3910, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3930, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3950, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3970, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 3990, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4010, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4030, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4070, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090, 4090};
/* 
 * Functions in sequencer module are dependent on this order for sorting through readings. 
 * Should this order be changed, make sure to account for it in other module receiving pot data. 
*/
static const uint8_t POT_ADC_ADDRESS[k_Pot_Id_Cnt] = {
    21, // VOLT 1 CH 1
    23, // VOLT 2 CH 1
    22, // VOLT 3 CH 1
    20, // VOLT 4 CH 1
    18, // VOLT 5 CH 1
    17, // VOLT 6 CH 1
    16, // VOLT 7 CH 1
    19, // VOLT 8 CH 1
    52, // VOLT 1 CH 2
    54, // VOLT 2 CH 2
    55, // VOLT 3 CH 2
    53, // VOLT 4 CH 2
    51, // VOLT 5 CH 2
    48, // VOLT 6 CH 2
    49, // VOLT 7 CH 2
    50, // VOLT 8 CH 2
    37, // TIME 1 CH 1
    39, // TIME 2 CH 1
    38, // TIME 3 CH 1
    36, // TIME 4 CH 1
    34, // TIME 5 CH 1
    33, // TIME 6 CH 1
    32, // TIME 7 CH 1
    35, // TIME 8 CH 1
    69, // TIME 1 CH 2
    71, // TIME 2 CH 2
    70, // TIME 3 CH 2
    68, // TIME 4 CH 2
    66, // TIME 5 CH 2
    65, // TIME 6 CH 2
    64, // TIME 7 CH 2
    67, // TIME 8 CH 2
    7,  // Param 1
    4,  // Param 2
    6   // Global 
};


/* *****************************************************************************
 * Private
 */

/* *****
 * Utils
 * *****/

static bool instance_contains_state_machine_ctx(
        struct Pot_Instance * p_inst,
        struct smf_ctx      * p_sm_ctx)
{
    return(&p_inst->sm == p_sm_ctx);
}

/* Find the instance that contains the state machine context. */
static struct Pot_Instance * sm_ctx_to_instance(struct smf_ctx * p_sm_ctx)
{
    /* Iterate thru the instances. */
    struct Pot_Instance * p_inst = NULL;
    SYS_SLIST_FOR_EACH_CONTAINER(&md.list.instances, p_inst, node.instance){
        if(instance_contains_state_machine_ctx(p_inst, p_sm_ctx)) return p_inst;
    }
    return(NULL);
}


static enum Pot_Id next_pot(enum Pot_Id id)
{
    return((id + 1) % k_Pot_Id_Cnt);
}

/* **************
 * Listener Utils
 * **************/

#if CONFIG_FKMG_POT_RUNTIME_ERROR_CHECKING
static enum Pot_Err_Id check_listener_cfg_param_for_errors(
        struct Pot_Listener_Cfg * p_cfg )
{
    if(!p_cfg
    || !p_cfg->p_iface
    || !p_cfg->p_lsnr) return(k_Pot_Err_Id_Configuration_Invalid);

    /* Is signal valid? */
    if(p_cfg->sig > k_Pot_Sig_Max)
        return(k_Pot_Err_Id_Configuration_Invalid);

    /* Is callback valid? */
    if(!p_cfg->cb)
        return(k_Pot_Err_Id_Configuration_Invalid);

    return(k_Pot_Err_Id_None);
}
#endif

static void clear_listener(struct Pot_Listener * p_lsnr)
{
    memset(p_lsnr, 0, sizeof(*p_lsnr));
}

static void config_listener(
        struct Pot_Listener     * p_lsnr,
        struct Pot_Listener_Cfg * p_cfg)
{
    /* Set listner's instance it is listening to. */
    p_lsnr->p_inst = p_cfg->p_inst;

    /* Set listner's callback. */ 
    p_lsnr->cb = p_cfg->cb;
}

static void init_listener(struct Pot_Listener * p_lsnr)
{
    clear_listener(p_lsnr);
}

/* **************
 * Instance Utils
 * **************/

#if CONFIG_FKMG_POT_RUNTIME_ERROR_CHECKING
static enum Pot_Err_Id check_instance_cfg_param_for_errors(
        struct Pot_Instance_Cfg * p_cfg)
{
    if(!p_cfg
    || !p_cfg->p_inst
    || !p_cfg->task.sm.p_thread
    || !p_cfg->task.sm.p_stack
    || !p_cfg->msgq.p_sm_evts) return(k_Pot_Err_Id_Configuration_Invalid);

    if(p_cfg->task.sm.stack_sz == 0) return(k_Pot_Err_Id_Configuration_Invalid);

    return(k_Pot_Err_Id_None);
}
#endif

static void add_instance_to_instances(
        struct Pot_Instance  * p_inst)
{
    sys_slist_append(&md.list.instances, &p_inst->node.instance);
}

static void config_instance_queues(
        struct Pot_Instance     * p_inst,
        struct Pot_Instance_Cfg * p_cfg)
{
    p_inst->msgq.p_sm_evts = p_cfg->msgq.p_sm_evts;
}

/* Forward reference */
static void on_conversion_timer_expiry(struct k_timer * p_timer);
/* Cause conversion event to occur immediately and then regularly after that. */
static void init_conversion_timer(struct Pot_Instance * p_inst)
{
    #define ON_CONVERSION_TIMER_EXPIRY  on_conversion_timer_expiry
    #define ON_CONVERSION_TIMER_STOPPED NULL
    k_timer_init(&p_inst->timer.conversion, ON_CONVERSION_TIMER_EXPIRY,
            ON_CONVERSION_TIMER_STOPPED);
}

static void config_instance_deferred(
        struct Pot_Instance     * p_inst,
        struct Pot_Instance_Cfg * p_cfg)
{

    init_conversion_timer(p_inst);

}

/* Since configuration starts on caller's thread, configure fields that require
 * immediate and/or inconsequential configuration and defer rest to be handled
 * by our own thread later. */
static void config_instance_immediate(
        struct Pot_Instance     * p_inst,
        struct Pot_Instance_Cfg * p_cfg)
{
    config_instance_queues(p_inst, p_cfg);
}

static void init_instance_lists(struct Pot_Instance * p_inst)
{
    for(enum Pot_Evt_Sig sig = k_Pot_Evt_Sig_Beg;
                         sig < k_Pot_Evt_Sig_End;
                         sig++){
        sys_slist_init(&p_inst->list.listeners[sig]);
    }
}

static void clear_instance(struct Pot_Instance * p_inst)
{
    memset(p_inst, 0, sizeof(*p_inst));
}

static void init_instance(struct Pot_Instance * p_inst)
{
    clear_instance(p_inst);
    init_instance_lists(p_inst);
    #if CONFIG_FKMG_POT_RUNTIME_ERROR_CHECKING
    p_inst->err = k_Pot_Err_Id_None;
    #endif
}




/* ************
 * Module Utils
 * ************/

static void init_module_lists(void)
{
    sys_slist_init(&md.list.instances);
}

static void clear_module(void)
{
    memset(&md, 0, sizeof(md));
}

static void init_module(void)
{
    if(md.initialized) return;
    clear_module();
    init_module_lists();
    md.initialized = true;
}

/* **************
 * Error Checking
 * **************/

#if CONFIG_FKMG_POT_RUNTIME_ERROR_CHECKING
static void set_error(
        struct Pot_Instance * p_inst,
        enum Pot_Err_Id       err,
        bool                  override)
{
    if(p_inst){
        if((override                          )
        || (p_inst->err == k_Pot_Err_Id_None )){
            p_inst->err = err;
        }
    }
}

static bool errored(
        struct Pot_Instance * p_inst,
        enum Pot_Err_Id       err )
{
    set_error(p_inst, err, NO_OVERRIDE);
    return(err != k_Pot_Err_Id_None);
}
#endif /* CONFIG_FKMG_POT_RUNTIME_ERR OR_CHECKING */

/* ************
 * Broadcasting
 * ************/

static void broadcast(
        struct Pot_Evt      * p_evt,
        struct Pot_Listener * p_lsnr)
{
    /* call the listener, passing the event */
    if(p_lsnr->cb)  p_lsnr->cb(p_evt);
}

static void broadcast_event_to_listeners(
        struct Pot_Instance * p_inst,
        struct Pot_Evt      * p_evt)
{

    enum Pot_Evt_Sig sig = p_evt->sig;
    struct Pot_Listener * p_lsnr = NULL;
    SYS_SLIST_FOR_EACH_CONTAINER(&p_inst->list.listeners[sig], p_lsnr, node.listener){
         broadcast(p_evt, p_lsnr);
    }

}

/* There's only 1 listener for instance initialization, and it is provided in
 * the cfg struct. */
static void broadcast_instance_initialized(
        struct Pot_Instance * p_inst,
        Pot_Listener_Cb       cb)
{
    struct Pot_Evt evt = {
            .sig = k_Pot_Evt_Sig_Instance_Initialized,
            .data.initd.p_inst = p_inst
    };

    struct Pot_Listener lsnr = {
        .p_inst = p_inst,
        .cb = cb
    };

    broadcast(&evt, &lsnr);
}

#if CONFIG_FKMG_POT_ALLOW_SHUTDOWN
static void broadcast_interface_deinitialized(
        struct Pot_Instance * p_inst,
        Pot_Listener_Cb       cb)
{
    struct Pot_Evt evt = {
            .sig = k_Pot_Instance_Deinitialized,
            .data.inst_deinit.p_inst = p_inst
    };

    struct Pot_Listener lsnr = {
        .p_inst = p_inst,
        .cb = cb
    };

    broadcast(&evt, &lsnr);
}
#endif

static void broadcast_pot_changed(
        struct Pot_Instance * p_inst,
        enum Pot_Id           id,
        uint16_t              val)
{

    struct Pot_Evt evt = {
            .sig = k_Pot_Evt_Sig_Changed,
            .data.changed.id = id,
            .data.changed.val = val
    };

    broadcast_event_to_listeners(p_inst, &evt);

}

/* **************
 * Listener Utils
 * **************/

static void add_listener_for_signal_to_listener_list(
    struct Pot_Listener_Cfg * p_cfg)
{
    /* Get pointer to interface to add listener to. */
    struct Pot_Instance * p_inst = p_cfg->p_inst;

    /* Get pointer to configured listener. */
    struct Pot_Listener * p_lsnr = p_cfg->p_lsnr;

    /* Get signal to listen for. */
    enum Pot_Evt_Sig sig = p_cfg->sig;

    /* Add listener to instance's specified signal. */
    sys_slist_t * p_list = &p_inst->list.listeners[sig];
    sys_snode_t * p_node = &p_lsnr->node.listener;
    sys_slist_append(p_list, p_node);
}

#if CONFIG_FKMG_POT_ALLOW_LISTENER_REMOVAL
static bool find_list_containing_listener_and_remove_listener(
    struct Pot_Instance * p_inst,
	struct Pot_Listener * p_lsnr)
{
    for(enum Pot_Evt_Sig sig = k_Pot_Evt_Sig_Beg;
                         sig < k_Pot_Evt_Sig_End;
                         sig++){
        bool found_and_removed = sys_slist_find_and_remove(
                &p_inst->list.listeners[sig], &p_lsnr->node);
        if(found_and_removed) return(true);
    }
    return( false );
}
#endif

// static bool signal_has_listeners(
//         struct Pot_Instance * p_inst,
//         enum Pot_Evt_Sig      sig)
// {
//     return(!sys_slist_is_empty(&p_inst->list.listeners[sig]));
// }

/* **************
 * Event Queueing
 * **************/

static void q_sm_event(struct Pot_Instance * p_inst, struct Pot_SM_Evt * p_evt)
{
    bool queued = k_msgq_put(p_inst->msgq.p_sm_evts, p_evt, K_NO_WAIT) == 0;

    if(!queued) assert(false);
}

static void q_init_instance_event(struct Pot_Instance_Cfg * p_cfg)
{
    struct Pot_SM_Evt evt = {
            .sig = k_Pot_SM_Evt_Sig_Init_Instance,
            .data.init_inst.cfg = *p_cfg
    };
    struct Pot_Instance * p_inst = p_cfg->p_inst;

    q_sm_event(p_inst, &evt);
}

static void q_force_pot_change(struct Pot_Instance * p_inst, enum Pot_Id id)
{
    struct Pot_SM_Evt evt = {
            .sig = k_Pot_SM_Evt_Sig_Force_Change,
            .data.force_change.id = id
    };
    q_sm_event(p_inst, &evt);
}

static void q_convert(struct Pot_Instance * p_inst, enum Pot_Id id)
{
    struct Pot_SM_Evt evt = {
            .sig = k_Pot_SM_Evt_Sig_Convert,
            .data.convert.id = id
    };

    q_sm_event(p_inst, &evt);
}

static void on_conversion_timer_expiry(struct k_timer * p_timer)
{
    struct Pot_Instance * p_inst =
        CONTAINER_OF(p_timer, struct Pot_Instance, timer.conversion);

    enum Pot_Id nextPotID = next_pot(p_inst->id);
    p_inst->id = nextPotID;
    q_convert(p_inst, nextPotID);

}

/* Cause conversion event to occur immediately and then regularly after that. */
static void start_conversion_timer(struct Pot_Instance * p_inst)
{
    #define CONVERSION_INITIAL_DURATION     K_MSEC(100)
    #define CONVERSION_AUTO_RELOAD_PERIOD   K_MSEC(1)
    k_timer_start(&p_inst->timer.conversion, CONVERSION_INITIAL_DURATION,
            CONVERSION_AUTO_RELOAD_PERIOD);

}

static void init_adc_device (struct Pot_Instance * p_inst) {

    if (!device_is_ready(adc_dev)) {
        LOG_ERR("ADC Configuration: Device Is NOT Ready.");
        return; 
    } else {
        // LOG_INF("ADC Device is READY"); 

        struct adc_channel_cfg adc_config = {
            .channel_id = ADC_CHANNEL,
            .gain = ADC_GAIN,
            .reference = ADC_REFERENCE,
            .acquisition_time = ADC_ACQ_TIME_DEFAULT
        }; 

        if (adc_channel_setup(adc_dev, &adc_config) != 0) {
            LOG_ERR("ADC Device set up: Failed");
            return; 
        } else {
            // LOG_INF("ADC Device set up: PASSED");
        }
    }

}

static void init_adc_gpios(struct Pot_Instance * p_inst) 
{
    if (    gpio_pin_configure_dt(&adc_address_0, GPIO_OUTPUT_INACTIVE)  ||
            gpio_pin_configure_dt(&adc_address_1, GPIO_OUTPUT_INACTIVE)  ||
            gpio_pin_configure_dt(&adc_address_2, GPIO_OUTPUT_INACTIVE)  ||
            gpio_pin_configure_dt(&adc_bank_0, GPIO_OUTPUT_INACTIVE | GPIO_PULL_UP)     ||
            gpio_pin_configure_dt(&adc_bank_1, GPIO_OUTPUT_INACTIVE | GPIO_PULL_UP)     ||
            gpio_pin_configure_dt(&adc_bank_2, GPIO_OUTPUT_INACTIVE | GPIO_PULL_UP)     ||
            gpio_pin_configure_dt(&adc_bank_3, GPIO_OUTPUT_INACTIVE | GPIO_PULL_UP)     ||
            gpio_pin_configure_dt(&adc_bank_4, GPIO_OUTPUT_INACTIVE | GPIO_PULL_UP)
    ){
        LOG_ERR("ADC GPIO Config: FAILED"); 
    }
}

static uint16_t adc_convert_pot (struct Pot_Instance * p_inst, enum Pot_Id id) 
{   
    uint32_t val = 0; 

    struct adc_sequence adc = {
        .channels = ADC_CHANNEL,
        .buffer = p_inst->adc_buffer,
        .buffer_size = sizeof(p_inst->adc_buffer),
        .resolution = ADC_RESOLUTION
    };

    if (adc_read(adc_dev, &adc) == 0) {
        val = p_inst->adc_buffer[0]; 
    }

    return val; 
} 

/* 
 * Pot Id is advanced in the argument at call for this fn. We only advance it here while we keep the current Pot Id intact for this cycle.
 * For the adc reading, the pot advancement occurs on timer expiry callback. 
 * POT_ADC_ADDRESS array contains all the information we need to set our muxes. First three bits (from LSB) tell us address pins to set on mux
 * while the second nybble tells us which mux to enable.
 * As it stands, Mux Address pins are on port B pins 0,1,2. Since these correspond directly to the bits of potAddress we're interested in, 
 * we can mask the rest of those bits and use this as our value. However, this step doesn't lend itself to a generic implementation as the
 * gpio_port_set_masked_raw function needs all pins to be on the same port. 
 */

static void advance_adc_mux(enum Pot_Id id) {
    uint8_t potAddress = POT_ADC_ADDRESS[id];
    // uint8_t potAddress = 21;
    uint32_t bank = (potAddress >> 4) & 0x0F; // Extract the 4 MSBs for the bank address
    uint32_t addressBits = potAddress & 0x0F; // Extract the 4 LSBs for the mux channel address

    // Mux Banks are off (Enable pin high)
    if (gpio_port_set_masked_raw(GPIOC_PORT, MUX_BANK_MASK, MUX_BANK_MASK)) {
        LOG_ERR("Error Setting Mux Banks Low");
    }

    // Set the address lines directly using the addressBits
    if (gpio_port_set_masked_raw(GPIOB_PORT, MUX_ADDR_MASK, addressBits)) {
        LOG_ERR("Error Setting Mux Address Pins");
    }

    // Set the correct Mux Bank high
    // Banks are mapped starting from PC4, we add 4 to the bank value to get the correct starting pin number
    uint32_t bank_mask_val = (1U << (bank + MUX_GPIO_OFFSET)); 
    if (gpio_port_set_masked_raw(GPIOC_PORT, MUX_BANK_MASK, ~bank_mask_val & MUX_BANK_MASK)) {
        LOG_ERR("Error Setting Mux Bank High");
    }
}



static uint16_t past_output[k_Pot_Id_Cnt] = {0};

static uint16_t adc_filter_pot(struct Pot_Instance * p_inst, enum Pot_Id id, uint16_t val) {
    // Coefficient for the EMA filter
    float alpha = 0.2f;
    
    // Threshold to determine significant change
    uint16_t threshold = 5;

    float newFilteredValue = past_output[id] + alpha * (val - past_output[id]);
    
    int16_t difference = abs(newFilteredValue - past_output[id]);
    
    if (difference > threshold) {
        past_output[id] = (uint16_t)newFilteredValue;
    }

    // Return the filtered value, which may or may not have been updated, depending on the threshold check
    return adc_lut[past_output[id]];
}


static bool did_pot_change (struct Pot_Instance * p_inst, enum Pot_Id id, uint16_t val) 
{
    int16_t difference = abs(val - p_inst->last_adc_read[id]);
    
    if (difference > 40) {
        p_inst->last_adc_read[id] = val;
        return true;
    }

    return false; 
};



static void populate_adc_pots_on_boot(struct Pot_Instance * p_inst) {
    for (int i = 0; i < k_Pot_Id_Cnt; i++) {
        past_output[i] = adc_convert_pot(p_inst, i);
        p_inst->last_adc_read[i] = past_output[i];
        advance_adc_mux(next_pot(i));
    }
}



/* **********
 * FSM States
 * **********/

/* The states are flat:
 *
 *  State init:
 *
 *  |entry          |  |run                |  |exit           |
 *  |---------------|  |-------------------|  |---------------|
 *  |not implemented|  |init instance:     |  |not implemented|
 *                     |* finish cfg.      |
 *                     |* ->run            |
 *                     |all other signals  |
 *                     |not allowed; assert|
 *
 *  State run:
 *
 *  |entry             |  |run             |  |exit           |
 *  |------------------|  |----------------|  |---------------|
 *  |* start conversion|  |convert:        |  |not implemented|
 *  |  timer           |  |* adc conversion|
 *                        |* advance mux   |
 *                        |* filter adc val|
 *                        |* broadcast if  |
 *                        | changed        |
 *                        |deinit:         |
 *                        |* ->deinit      |
 *                        |all others:     |
 *                        |* assert        |
 *
 *  State deinit:
 *
 *  |entry             |  |run                 |  |exit           |
 *  |------------------|  |--------------------|  |---------------|
 *  |* start conversion|  |* finish dcfg.      |  |not implemented|
 *  |  timer           |  |* exit state machine|
 *                        |all others:         |
 *                        |* assert            |
 *
 *  Legend:
 *  "entry state": 1st state of state machine
 *  "xxx:"       : signal to handle
 *  "*"          : action to take on signal
 *  "-> xxx"     : state to change to
 *  "^ xxx"      : pass signal to parent, with expected parent action on signal.
 */


/* Forward declaration of state table */
static const struct smf_state states[];

enum state{
    init,   // Init instance - should only occur once, after thread start
    run,    // Run - handles all events while running (e.g. conversion, etc.)
    deinit, // Deinit instance - should only occur once, after deinit event
            // (if implemented)
};

/* NOTE: in all the state functions the param o is a pointer to the state
 * machine context, which is &p_inst->sm. */

/* Init state responsibility is to complete initialization of the instance, let
 * an instance config listener know we've completed initialization (i.e. thread
 * is up and running), and then transition to next state. Init state occurs
 * immediately after thread start and is expected to only occur once. */

static void state_init_run(void * o)
{
    struct smf_ctx * p_sm = o;
    struct Pot_Instance * p_inst = sm_ctx_to_instance(p_sm);

    /* Get the event. */
    struct Pot_SM_Evt * p_evt = &p_inst->sm_evt;

    /* Expecting only an "init instance" event. Anything else is an error. */
    assert(p_evt->sig == k_Pot_SM_Evt_Sig_Init_Instance);

    /* We init'd required params on the caller's thread (i.e.
     * Pot_Init_Instance()), now finish the job. Since this is an
     * Init_Instance event the data contains the intance cfg. */
    struct Pot_SM_Evt_Sig_Init_Instance * p_ii = &p_evt->data.init_inst;
    
    populate_adc_pots_on_boot(p_inst); 
    config_instance_deferred(p_inst, &p_ii->cfg);
    broadcast_instance_initialized(p_inst, p_ii->cfg.cb);

    smf_set_state(SMF_CTX(p_sm), &states[run]);
}

/* Run state responsibility is to be the root state to handle everything else
 * other than instance initialization. */

static void state_run_entry(void * o)
{

    struct smf_ctx * p_sm = o;
    struct Pot_Instance * p_inst = sm_ctx_to_instance(p_sm);
    start_conversion_timer(p_inst);
}

static void state_run_run(void * o)
{
    struct smf_ctx * p_sm = o;
    struct Pot_Instance * p_inst = sm_ctx_to_instance(p_sm);

    /* Get the event. */
    struct Pot_SM_Evt * p_evt = &p_inst->sm_evt;

    switch(p_evt->sig){
        default: break;
        case k_Pot_SM_Evt_Sig_Init_Instance:
            /* Should never occur. */
            assert(false);
            break;
        case k_Pot_SM_Evt_Sig_Convert:
            struct Pot_SM_Evt_Sig_Convert * p_convert = &p_evt->data.convert;

            uint16_t val = adc_convert_pot(p_inst, p_convert->id);
            
            advance_adc_mux(next_pot(p_convert->id));
            
            uint16_t filtered_reading = adc_filter_pot(p_inst, p_convert->id, val);
            // printk("%d\n", filtered_reading);
            
            // if (did_pot_change(p_inst, p_convert->id, filtered_reading)) {           
            broadcast_pot_changed(p_inst, p_convert->id, filtered_reading);
            // }


            // }

             break;
        #if CONFIG_FKMG_POT_SHUTDOWN_ENABLED
        case k_Pot_Evt_Sig_Instance_Deinitialized:
            assert(false);
            break;
        #endif
    }
}

/* Deinit state responsibility is to clean up before exiting thread. */
#if CONFIG_FKMG_POT_SHUTDOWN_ENABLED
static void state_deinit_run(void * o)
{
    struct smf_ctx * p_sm = o;
    struct Pot_Instance * p_inst = sm_ctx_to_instance(p_sm);

    /* Get the event. */
    struct Pot_SM_Evt * p_evt = &p_inst->sm_evt;

    /* TODO */
}
#endif

static const struct smf_state states[] = {
    /*                                      entry               run  exit */
    [  init] = SMF_CREATE_STATE(           NULL,   state_init_run, NULL),
    [   run] = SMF_CREATE_STATE(state_run_entry,    state_run_run, NULL),
    #if CONFIG_FKMG_POT_SHUTDOWN_ENABLED
    [deinit] = SMF_CREATE_STATE(           NULL, state_deinit_run, NULL),
    #endif
};

/* ******
 * Thread
 * ******/

#if CONFIG_FKMG_POT_ALLOW_SHUTDOWN
/* Since there is only the "join" facility to know when a thread is shut down,
 * and that isn't appropriate to use since it will put the calling thread to
 * sleep until the other thread is shut down, we set up a delayable system work
 * queue event to check that the thread is shut down and then call any callback
 * that is waiting to be notified. */
void on_thread_shutdown(struct k_work *item)
{
    struct Pot_Instance * p_inst =
            CONTAINER_OF(item, struct Pot_Instance, work);

    char * thread_state_str = "dead";
    k_thread_state_str(&p_inst->thread, thread_state_str, sizeof(thread_state_str));
    bool shut_down = strcmp( thread_state_str, "dead" ) == 0;

    if(!shut_down) k_work_reschedule(&p_inst->work, K_MSEC(1));
    else broadcast_instance_deinitialized(p_inst);
}
#endif

static void thread(void * p_1, /* struct Pot_Instance* */
        void * p_2_unused, void * p_3_unused)
{
    struct Pot_Instance * p_inst = p_1;
    /* NOTE: smf_set_initial() executes the entry state. */
    struct smf_ctx * p_sm = &p_inst->sm;
    smf_set_initial(SMF_CTX(p_sm), &states[init]);

    /* Get the state machine event queue and point to where to put the dequeued
     * event. */
    struct k_msgq * p_msgq = p_inst->msgq.p_sm_evts;
    struct Pot_SM_Evt * p_evt = &p_inst->sm_evt;

    bool run = true;

    while(run){
        /* Wait on state machine event. Cache it then run state machine. */
        k_msgq_get(p_msgq, p_evt, K_FOREVER);
        run = smf_run_state(SMF_CTX(p_sm)) == 0;
    }

    #if CONFIG_FKMG_POT_ALLOW_SHUTDOWN
    /* We're shutting down. Schedule a work queue event to check that the
     * thread exited and call back anything. */
    if(should_callback_on_exit(p_inst)){
        k_work_init_delayable( &p_inst->work, on_thread_shutdown);
        k_work_schedule(&p_inst->work, K_MSEC(1));
    }
    #endif
}

static void start_thread(
        struct Pot_Instance     * p_inst,
        struct Pot_Instance_Cfg * p_cfg)
{
    struct k_thread  * p_thread = p_cfg->task.sm.p_thread;
    k_thread_stack_t * p_stack  = p_cfg->task.sm.p_stack;
    size_t stack_sz_bytes = p_cfg->task.sm.stack_sz;
    int prio = p_cfg->task.sm.prio;

    /* Start the state machine thread. */
    p_inst->task.sm.p_thread = k_thread_create(
        p_thread,       // ptr to uninitialized struct k_thread
        p_stack,        // ptr to the stack space
        stack_sz_bytes, // stack size in bytes
        thread,         // thread entry function
        p_inst,         // 1st entry point parameter
        NULL,           // 2nd entry point parameter
        NULL,           // 3rd entry point parameter
        prio,           // thread priority 
        0,              // thread options
        K_NO_WAIT);     // scheduling delay
    assert(p_inst->task.sm.p_thread == p_thread);
}

/* *****************************************************************************
 * Public
 */

void Pot_Init_Instance(struct Pot_Instance_Cfg * p_cfg)
{
    /* Get pointer to instance to configure. */
    struct Pot_Instance * p_inst = p_cfg->p_inst;

    #if CONFIG_FKMG_POT_RUNTIME_ERROR_CHECKING
    /* Check instance configuration for errors. */
    if(errored(p_inst, check_instance_cfg_param_for_errors(p_cfg))){
        assert(false);
        return;
    }
    #endif

    init_adc_gpios(p_inst);
    init_adc_device(p_inst);

    init_module();
    init_instance(p_inst);
    config_instance_immediate(p_inst, p_cfg);
    add_instance_to_instances(p_inst);
    start_thread(p_inst, p_cfg);
    q_init_instance_event(p_cfg);
}

#if CONFIG_FKMG_POT_ALLOW_SHUTDOWN
void Pot_Deinit_Instance(struct Pot_Instance_Dcfg * p_dcfg)
{
    #error "Not implemented yet!"
}
#endif

void Pot_Add_Listener(struct Pot_Listener_Cfg * p_cfg)
{
    #if CONFIG_FKMG_POT_RUNTIME_ERROR_CHECKING
    /* Get pointer to instance. */
    struct Pot_Instance * p_inst = p_cfg->p_inst;

    /* Check listener instance configuration for errors. */
    if(errored(p_inst, check_listener_cfg_param_for_errors(p_cfg))){
        assert(false);
        return;
    }
    #endif

    struct Pot_Listener * p_lsnr = p_cfg->p_lsnr;
    init_listener(p_lsnr);
    config_listener(p_lsnr, p_cfg);
    add_listener_for_signal_to_listener_list(p_cfg);

}

#if CONFIG_FKMG_POT_ALLOW_LISTENER_REMOVAL
void Pot_Remove_Listener(struct Pot_Listener * p_lsnr)
{
    #error "Not implemented yet!"
}
#endif





#if CONFIG_FKMG_POT_NO_OPTIMIZATIONS
#pragma GCC pop_options
#endif
